\documentclass[a4paper,10pt]{article}
\usepackage{amsmath}
\usepackage{enumitem}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{pgfgantt}
\definecolor{blue}{HTML}{74BBC9}
\definecolor{green}{HTML}{A9D454}
\definecolor{yellow}{HTML}{F7E967}
\definecolor{red}{HTML}{F24440}
\definecolor{darkblue}{HTML}{425D69}
\definecolor{orange}{HTML}{FF9036}
\definecolor{violet}{RGB}{216,3,240}

\usepackage[backend=biber, style=numeric, sorting=none]{biblatex}
\addbibresource{paper.bib}

\title{A local search approach for flexible job shop problems}
\author{Alex van Poppelen\smallskip\\
\emph{Supervisor:} Dr. J.A. Hoogeveen}

\begin{document}

\maketitle

\begin{abstract}

This is my abstract.

\end{abstract}

\tableofcontents

\section{Introduction}

\subsection{General introduction}

The Job Shop problem looks at the problem of scheduling multi operation jobs on a set of machines, where each operation in a job needs to be processed on a certain machine. The Job Shop problem is well known to be NP-hard in the strong sense, and notoriously difficult to solve even compred to other NP-hard problems.

In this paper, the Flexible Job Shop (FJS) and the Flexible Blocking Job Shop (FBJS) problems are considered. These two problems are an extension of the Job Shop and Blocking Job Shop problems where individual machines required by each operation are replaced by a number of identical machines running in parallel. Because of the need to assign operations to machines, the FJS is more complex than the classical Job Shop problem. It is therefore also known to be strongly NP-hard \cite{approxfjsp}.

In the remainder of the first section, the FJS is formally defined. The blocking constraint is also defined. In the second section, a local search approach to solve the FJS is explored. Finally, the local search approach is modified to accomodate the blocking constraints in the third section.

\subsection{Formal definition}

The Flexible Job Shop problem is defined as follows. We are given a set of $n$ jobs.

\[ \mathcal{J} = \{J_1, \dots, J_n\} \]

Each job $J_i$ consists of a fixed sequence of operations, where $o_i$ refers to the number of operations in the job:

\[ \mathcal{O}_i = \{O_{i,1}, \dots, O_{i, o_i}\} \]

Where $\mathcal{O}$ refers to the set of all operations (in this paper, individual operations will sometimes be referred to with a single subscript; in this case it will be clear from the context whether this refers to a set of job operations or a single operation). Each operation $O_{i,j}$ must be processed on a predetermined machine type.

\[ T_{i,j} \in \mathcal{T} = \{T_1, \dots, T_t\} \]

Each machine type $T_k$ has a given number of machines, defined as $m_k$. We will use $T_{k,l}$ to refer to the $l$-th machine of type $T_k$. Furthermore, each operation $O_{i,j}$ has a processing time $p_{i,j} > 0$ and a delay time $w_{i,j} \geq 0$.

Machines are assumed to be continuously available from time 0, and can complete at most one operation at a time. Preemption is not allowed; the processing time $p_{i,j}$ must be uninterrupted. The delay time $w_{i,j}$ is defined as the time that must pass after operation $O_{i,j}$ is completed, before $O_{i,j + 1}$ may begin. Note that the machine $O_{i,j}$ was being processed on is immediately available.

We are interested in the following objective function.

\[ \min \{ C_\text{max} \} \]

Where $C_\text{max}$ is defined as the maximum completion time, or the time at which the last machine finished. This will be referred to as the \emph{makespan} of a schedule for the rest of this paper.

In some other literature describing the Flexible Job Shop problem, there is no concept of a machine type. Instead, each operation is defined to be processed on some subset of the set of all machines \cite{approxfjsp}. This formulation is more general than the one used in this paper.

As a result, our definition of the FJS may exclude applications in settings that combine machines suited to highly specific tasks with more generalized machines, capable of processing a larger variety of operations.

\subsection{Blocking constraint extension}

In some situations, it may be unrealistic to model a scheduling problem as a Flexible Job Shop instance. For example, a manufacturing scenario might introduce storage space constraints. The FJS assumes that a job finished processing on one machine can be removed and placed into an intermediate buffer immediately, while waiting for it to be scheduled onto the next machine. This assumption may be impractical, and a factory might not have room for any intermediate buffers.

We can extend the problem definition to account for these constraints. In the Flexible Blocking Job Shop problem, a machine that is finished processing a job will be blocked until that job can be moved and processed by a successive machine. Note that this definition removes the distinction between the processing times and waiting times defined above, since the machine will be blocked for the duration of the waiting time regardless of whether subsequent machines are available or not.

This definition introduces several new possible scenarios that must be resolved. For example, what happens when machine $T_{1,1}$ is blocked, waiting for machine $T_{2,1}$ to be freed, while $T_{2,1}$ is blocked waiting for $T_{1,1}$? This depends on the problem scenario, and the mechanisms in place to transfer jobs between machines. In this paper, we will assume that these mechanisms are capable of simultaneously swapping jobs between all blocked machines. Thus, any \emph{blocking cycles} will not cause a deadlock in the schedule.

\section{A local search approach to the FSJ}

In solving the FSJ, we are tasked with two problems. The first is to assign operations to machines. The second is to define an order on the set of operations assigned to every machine. We can choose to tackle these problems independently, or at the same time. In the independent approach, the operations would first be assigned to machines, reducing the problem to the classical Job Shop. In this paper, we will choose to tackle the problems at the same time, using a more complex schedule serialization function.

\subsection{Representation}

The classical Job Shop problem is often modeled as a disjunctive graph (for example, see \textbf{Figure \ref{fig:disjunctivegraph}}), where the directed arcs represent the precedence constraints within a job, and the undirected edges represent operations that must be processed on the same machine. By defining a direction on the edges, and making sure that these definitions result in an acyclic graph, one obtains a valid schedule for the Job Shop instance. In this case, an undirected edge represents a non-simultaneity constraint -- the two operations may be processed in any order, but not at the same time. If we wish to use the same definition for the FSJ, we are forced to assign operations to machines before directing the edges. However, that splits the problem into two parts as mentioned above, and will increase the complexity of the neighborhood. We will take another approach.

\begin{figure}[h]
\centering
\begin{tikzpicture}

\tikzset{vertex/.style = {shape=circle,draw}}
\tikzset{arc/.style = {->,>=latex}}

% vertices
\node[vertex] (1) at  (0,0) {1};
\node[vertex] (2) at  (1.5,0) {2};
\node[vertex] (3) at  (3,0) {3};
\node[vertex] (4) at  (4.5,0) {4};
\node[vertex] (5) at  (0,-1.1) {5};
\node[vertex] (6) at  (1.5,-1.1) {6};
\node[vertex] (7) at  (0,-2.2) {7};
\node[vertex] (8) at  (1.5,-2.2) {8};

% labels
\node [left] at (-1,0) {$J_1$};
\node [left] at (-1,-1.1) {$J_2$};
\node [left] at (-1,-2.2) {$J_3$};

% arcs
\draw[arc] (1) to (2);
\draw[arc] (2) to (3);
\draw[arc] (3) to (4);
\draw[arc] (5) to (6);
\draw[arc] (7) to (8);

% edges
\draw (1) to (8);
\draw (3) to (5);
\draw [bend left=20] (3) to (7);
\draw (5) to (7);
\draw (2) to (6);
\draw (4) to (6);

\end{tikzpicture}
\caption{A disjunctive graph representing 3 jobs on 3 machines}
\label{fig:disjunctivegraph}
\end{figure}

We decide to modify the definition of an undirected edge. Instead, it will define two operations that may be processed in any order on the same machine, or independently on two different machines of the same type. Directing these edges will define the order of processing in the case the operations are on the same machine. In the case that they aren't, it only means that the start time of the second operation is equal to or greater than the start time of the first operation. This will make the serialization of a schedule more difficult, but the advantage is that generating the neighborhood will be easier.

In our representation, we can ascertain the following information from \textbf{Figure \ref{fig:disjunctivegraph}}. There are three jobs. Operations 1 and 8 must be processed by the same machine type. Similarly, operations 2, 4, and 6 are processed on another, and 3, 5, and 7 on the last machine type.

\subsection{Serializing the schedule}

Once all the edges in the disjunctive graph have been given directions, such that the graph is acyclic, it is possible to generate the schedule. The serialization function will assign operations to machines, and calculate the start time for each operation. The makespan can be determined after this process. It is important that the graph representation combined with the serialization function spans the entire set of feasible schedules. Furthermore, the serialization function should be deterministic in order to allow the local search to do its work.

To do this, we place the unscheduled operations in ordered queues for each machine type $T_k$. We take the first operation that has no unscheduled job predecessor, and schedule it greedily into the first available machine, taking care to schedule it at the same start time or after that of the previously scheduled operation for that type. This ensures the ordering on the operations is preserved in the schedule, and conforms to the requirements we laid out earlier in the representation section. Scheduling operations before the starting time of a previously scheduled operation on the same machine type can lead to a schedule that is actually infeasible.

If there is no operation without an unscheduled job predecessor, then there exists a cycle in the graph, and the schedule serialization fails.

We could choose to apply several tricks to generate a better schedule, but instead we will let the local search do that for us by modifying the order of the operations for each machine type.

\subsubsection{Schedule serialization example}

\begin{figure}[h]
\centering
\begin{tikzpicture}

\tikzset{vertex/.style = {shape=circle,draw}}
\tikzset{arc/.style = {->,>=latex}}

% vertices
\node[vertex] (1) at  (0,0) {1};
\node[vertex] (2) at  (1.5,0) {2};
\node[vertex] (3) at  (3,0) {3};
\node[vertex] (4) at  (4.5,0) {4};
\node[vertex] (5) at  (0,-1.1) {5};
\node[vertex] (6) at  (1.5,-1.1) {6};
\node[vertex] (7) at  (0,-2.2) {7};
\node[vertex] (8) at  (1.5,-2.2) {8};

% labels
\node [left] at (-1,0) {$J_1$};
\node [left] at (-1,-1.1) {$J_2$};
\node [left] at (-1,-2.2) {$J_3$};

% arcs
\draw[arc] (1) to (2);
\draw[arc] (2) to (3);
\draw[arc] (3) to (4);
\draw[arc] (5) to (6);
\draw[arc] (7) to (8);

% edges
\draw[arc] (1) to (8);
\draw[arc] (5) to (3);
\draw[arc] [bend right=20] (7) to (3);
\draw[arc] (7) to (5);
\draw[arc] (2) to (6);
\draw[arc] (6) to (4);

\end{tikzpicture}
\caption{An acyclic directed graph representing a schedule}
\label{fig:dag}
\end{figure}

Consider the acyclic directed graph in \textbf{Figure \ref{fig:dag}}. The serialization function would set up three ordered queues:

\[ O_1 \rightarrow O_8 \]
\[ O_2 \rightarrow O_6 \rightarrow O_4 \]
\[ O_7 \rightarrow O_5 \rightarrow O_3 \]

Since operation $O_2$ has an unscheduled job predecessor, the algorithm would schedule $O_1$ or $O_7$ at time 0 on their respective machines first. After $O_1$ is scheduled, $O_2$ would become available to be scheduled at time $p_{1,1} + w_{1,1}$ or later. The algorithm continues until all the queues are empty or a cycle has been found. In the first case, the makespan is easily determined as the largest finish time for all the operations.

\subsection{Critical path neighborhood}

For the classical Job Shop problem, a commonly used neighborhood is the set of all critical block swaps. The critical block swap is a reversal of an edge on the longest path of the disjunctive graph. This neighborhood is quite small, focusing on the operations that influence the length of the makespan. More importantly, the neighborhood is guaranteed to consist only of other acyclic graphs, or feasible solutions \cite{simulatedannealingjsp}.

For the FJS, we can define the longest path in a similar manner. Whereas the longest path for the classical Job Shop problem was also chronologically sequential in terms of the generated schedule, this is no longer necessarily the case for the FJS. We must also consider operations on the same machine type, scheduled on different machines. For example, consider the operations $O_{1,1}$ and $O_{2,2}$ from different jobs that must be scheduled on machines of type $T$, connected by a directed edge from $O_{1,1}$ to $O_{2,2}$. Suppose $O_{1,1}$ has been scheduled at time $t_1$ on machine $M_1$ of type $T$ due to a precedence constraint. Further suppose that machine $M_2$, also of type $T$, is available from some time $t_2 < t_1$. However, the serialization function is forced to schedule $O_{2,2}$ on $M_2$ at time $t_1$ anyway. In this scenario, we would like to reverse the order of the arc between $O_{1,1}$ and $O_{2,2}$, so that $O_{2,2}$ may be scheduled earlier and therefore potentially decrease the length of the longest path.

Therefore, we construct our neighborhood by considering operations $v$ and $w$ such that:

\begin{itemize}
	\item $v$ and $w$ have both been scheduled consecutively on the same machine
	\item $v$ and $w$ have been scheduled on different machines of the same type at the same time
\end{itemize}

\subsubsection{Applying the swap}

Let's consider the absolute ordering on the set of operations on a machine type, as defined by the acyclic directed graph corresponding to a feasible schedule. In the classical Job Shop case, a critical block swap identifies two consecutively scheduled nodes on a machine. These two nodes are necessarily consecutive in the absolute ordering, as well. In the FJS problem, this is no longer necessarily the case, since operations in between may have been scheduled on other machines of the same type. If one of these other operations is of the same job as either of the selected nodes, simply reversing the directed edge between the two nodes will lead to one or more cycles.

\begin{figure}[h]
\centering
\begin{ganttchart}[
		x unit=0.7cm,
		y unit chart=0.7cm,
		canvas/.style={draw=none,fill=none},
		vgrid,
		vgrid={*1{draw=black!12}},
		inline,
		group/.style={draw=none,fill=none},
		bar top shift=0.1,
		bar height=0.8,
		y unit title=0.5cm,
		title/.style={draw=none,fill=none},
		include title in canvas=false,
	]{-1}{12}

	\gantttitle{0}{2}
	\gantttitle{2}{2}
	\gantttitle{4}{2}
	\gantttitle{6}{2}
	\gantttitle{8}{2}
	\gantttitle{10}{2}
	\gantttitle{12}{2} \\

	\ganttgroup[inline=false]{$T_{1,1}$}{0}{1}
	\ganttbar[bar/.style={fill=yellow}]{2,12}{3}{4}
	\ganttbar[bar/.style={fill=blue}]{1,10}{6}{7} \\

	\ganttgroup[inline=false]{$T_{1,2}$}{0}{1}
	\ganttbar[bar/.style={fill=blue}]{1,9}{2}{5}
	\ganttbar[bar/.style={fill=yellow}]{2,13}{6}{8} \\

	\ganttgroup[inline=false]{$T_{2,1}$}{0}{1}
	\ganttbar[bar/.style={fill=blue}]{1,8}{0}{1}
	\ganttbar[bar/.style={fill=yellow}]{2,14}{9}{11} \\
	
	\ganttgroup[inline=false]{$T_{3,1}$}{0}{1}
	\ganttbar[bar/.style={fill=yellow}]{2,11}{0}{2}

\end{ganttchart}
\caption{A flexible job shop schedule}
\label{fig:sch-swap}
\end{figure}

Consider the schedule shown in \textbf{Figure \ref{fig:sch-swap}}. The absolute ordering that generated this schedule follows:

\[ O_{1,9} \rightarrow O_{2,12} \rightarrow O_{1,10} \rightarrow O_{2,13} \]

We wish to swap the order of operations $O_{1,9}$ and $O_{2,13}$, both on the critical path. Simply swapping their places leads to cycles, since the job operations will be out of order. We can resolve this situation by reversing a few more arcs, to achieve the following absolute ordering.

\[ O_{2,12} \rightarrow O_{2,13} \rightarrow O_{1,9} \rightarrow O_{1,10} \]

This can be done by incrementely swapping both target operations inwards, stopping if the swap would occur with another operation of the same job, or if the two target operations have switched order. This preserves the order among all operations exluding the two targets. Although this swap is now bounded by $O(n)$ in the worst case, in practice it will be much faster, since the two operations being swapped are chronologically sequential. It can be shown that this type of swap for two operations on the longest path can always be done without creating any cycles within the machine type.

Suppose the method above was not able to swap two operations, $O_{i,a_1}$ and $O_{j,b_2}$ for $i \neq j$. Then there exist operations $O_{i,a_2}$ and $O_{j,b_1}$ with $a_1 < a_2$ and $b_1 < b_2$ such that the absolute order is equivalent to the following:

\[ \dots \rightarrow O_{i,a_1} \rightarrow \dots \rightarrow O_{i,a_2} \rightarrow \dots O_{j,b_1}
\rightarrow \dots \rightarrow O_{j,b_2} \rightarrow \dots \]

This configation does not allow for the above swap without changing the order between the two inner operations, since it would create a cycle. However, it is easy to see that such an ordering will never create a schedule such that $O_{i,a_1}$ and $O_{j,b_2}$ are consecutive on the longest path, since operation $O_{j,b_1}$ has a non-zero processing time, and cannot be scheduled until after or equal to the finish time of $O_{i,a_1}$ due to $O_{i,a_2}$.

\subsubsection{Infeasible solutions}

The critical path neighborhood for the classical Job Shop is guaranteed to consist of only feasible schedules, a very nice result from Van Laarhoven et al \cite{simulatedannealingjsp}. Unfortunately, this is not the case for the Flexible Job Shop. We have slightly modified the swap operation to ensure no cycles within a machine type are created. However, this does not guarantee no cycles in the entire graph are generated. Consider the schedule shown in \textbf{Figure \ref{fig:sch-cycle}}, where colors correspond to jobs.

\begin{figure}[h]
\centering
\begin{ganttchart}[
		x unit=0.7cm,
		y unit chart=0.7cm,
		canvas/.style={draw=none, fill=none},
		vgrid,
		vgrid={*1{draw=black!12}},
		inline,
		group/.style={draw=none, fill=none},
		bar top shift=0.1,
		bar height=0.8,
		y unit title=0.5cm,
		title/.style={draw=none, fill=none},
		%title label/.style={align=left},
		include title in canvas=false,
	]{655}{669}

	\gantttitle{656}{2}
	\gantttitle{658}{2}
	\gantttitle{660}{2}
	\gantttitle{662}{2}
	\gantttitle{664}{2}
	\gantttitle{666}{2}
	\gantttitle{668}{2} \\

	\ganttgroup[inline=false]{$T_{1,1}$}{656}{657}
	\ganttbar[bar/.style={fill=blue}]{1225}{656}{664}
	\ganttbar[bar/.style={fill=green}]{1298}{665}{668} \\

	\ganttgroup[inline=false]{$T_{1,2}$}{656}{657}
	\ganttbar[bar/.style={fill=yellow}]{905}{657}{665} \\

	\ganttgroup[inline=false]{$T_{1,3}$}{656}{657}
	\ganttbar[bar/.style={fill=darkblue}]{1009}{657}{658}
	\ganttbar[bar/.style={fill=red}]{1055}{659}{661}
	\ganttbar[bar/.style={fill=orange}]{1249}{662}{668} \\

	\ganttgroup[inline=false]{$\dots$}{656}{657} \\

	\ganttgroup[inline=false]{$T_{4,1}$}{656}{657}
	\ganttbar[bar/.style={fill=darkblue}]{1010}{660}{663} \\

	\ganttgroup[inline=false]{$T_{4,4}$}{656}{657}
	\ganttbar[bar/.style={fill=green}]{1297}{660}{660}

\end{ganttchart}
\caption{A flexible job shop schedule}
\label{fig:sch-cycle}
\end{figure}

The acyclic directed graph that generated this schedule could have the following partial absolute ordering on machine type $T_1$:

\[ \dots \rightarrow O_{1225} \rightarrow O_{905} \rightarrow O_{1009} \rightarrow O_{1055} \rightarrow O_{1249} \rightarrow O_{1298} \rightarrow \dots \]

The ordering on $T_4$ could have $O_{1010}$ placed before $O_{1297}$. Suppose that $O_{1225}$ and $O_{1298}$ were on the critical path, and have been selected for a swap. Applying the swap operation as described above would simply move $O_{1298}$ to the front of the chain. A cycle is created, from $O_{1010} \rightarrow O_{1297} \rightarrow O_{1298} \rightarrow O_{1009}$ and back to $O_{1010}$.

In this case, we could perform checks and swap the two operations after the offending $O_{1009}$. However, correcting for one cycle could potentially lead to another, and the operation would become very expensive. In practice, these kinds of cycles rarely occur, and it is better to simply reverse the swap and allow the heuristic to try something else.

\subsection{Computational results}

Here are some results.

\section{A local search approach to the FBSJ}

\subsection{Changes}

Intuitively, we can use the exact same representation and neighborhood for the FBJS problem as for the FJS.

%\addcontentsline{toc}{section}{References}
\printbibliography[heading=bibintoc]

\end{document}
